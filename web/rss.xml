<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>27 Apr 2020 00:00:00 +0000</pubDate>
    <item>
       <title>Attack Trees in Isabelle for GDPR compliance of IoT healthcare systems</title>
              <link>https://www.isa-afp.org/entries/Attack_Trees.html</link>
       <guid>https://www.isa-afp.org/entries/Attack_Trees.html</guid>
       <dc:creator> Florian Kammueller       </dc:creator>
       <pubDate>27 Apr 2020 00:00:00 +0000</pubDate>
       <description>
In this article, we present a proof theory for Attack Trees. Attack
Trees are a well established and useful model for the construction of
attacks on systems since they allow a stepwise exploration of high
level attacks in application scenarios. Using the expressiveness of
Higher Order Logic in Isabelle, we develop a generic
theory of Attack Trees with a state-based semantics based on Kripke
structures and CTL. The resulting framework
allows mechanically supported logic analysis of the meta-theory of the
proof calculus of Attack Trees and at the same time the developed
proof theory enables application to case studies. A central
correctness and completeness result proved in Isabelle establishes a
connection between the notion of Attack Tree validity and CTL. The
application is illustrated on the example of a healthcare IoT system
and GDPR compliance verification.</description>
    </item>
    <item>
       <title>Authenticated Data Structures As Functors</title>
              <link>https://www.isa-afp.org/entries/ADS_Functor.html</link>
       <guid>https://www.isa-afp.org/entries/ADS_Functor.html</guid>
       <dc:creator> Andreas Lochbihler, Ognjen Marić       </dc:creator>
       <pubDate>16 Apr 2020 00:00:00 +0000</pubDate>
       <description>
Authenticated data structures allow several systems to convince each
other that they are referring to the same data structure, even if each
of them knows only a part of the data structure. Using inclusion
proofs, knowledgeable systems can selectively share their knowledge
with other systems and the latter can verify the authenticity of what
is being shared.  In this article, we show how to modularly define
authenticated data structures, their inclusion proofs, and operations
thereon as datatypes in Isabelle/HOL, using a shallow embedding.
Modularity allows us to construct complicated trees from reusable
building blocks, which we call Merkle functors. Merkle functors
include sums, products, and function spaces and are closed under
composition and least fixpoints.  As a practical application, we model
the hierarchical transactions of &lt;a
href=&#34;https://www.canton.io&#34;&gt;Canton&lt;/a&gt;, a
practical interoperability protocol for distributed ledgers, as
authenticated data structures. This is a first step towards
formalizing the Canton protocol and verifying its integrity and
security guarantees.</description>
    </item>
    <item>
       <title>Formalization of an Algorithm for Greedily Computing Associative Aggregations on Sliding Windows</title>
              <link>https://www.isa-afp.org/entries/Sliding_Window_Algorithm.html</link>
       <guid>https://www.isa-afp.org/entries/Sliding_Window_Algorithm.html</guid>
       <dc:creator> Lukas Heimes, Dmitriy Traytel, Joshua Schneider       </dc:creator>
       <pubDate>10 Apr 2020 00:00:00 +0000</pubDate>
       <description>
Basin et al.&#39;s &lt;a
href=&#34;https://doi.org/10.1016/j.ipl.2014.09.009&#34;&gt;sliding
window algorithm (SWA)&lt;/a&gt; is an algorithm for combining the
elements of subsequences of a sequence with an associative operator.
It is greedy and minimizes the number of operator applications. We
formalize the algorithm and verify its functional correctness. We
extend the algorithm with additional operations and provide an
alternative interface to the slide operation that does not require the
entire input sequence.</description>
    </item>
    <item>
       <title>A Comprehensive Framework for Saturation Theorem Proving</title>
              <link>https://www.isa-afp.org/entries/Saturation_Framework.html</link>
       <guid>https://www.isa-afp.org/entries/Saturation_Framework.html</guid>
       <dc:creator> Sophie Tourret       </dc:creator>
       <pubDate>09 Apr 2020 00:00:00 +0000</pubDate>
       <description>
This Isabelle/HOL formalization is the companion of the technical
report “A comprehensive framework for saturation theorem proving”,
itself companion of the eponym IJCAR 2020 paper, written by Uwe
Waldmann, Sophie Tourret, Simon Robillard and Jasmin Blanchette. It
verifies a framework for formal refutational completeness proofs of
abstract provers that implement saturation calculi, such as ordered
resolution or superposition, and allows to model entire prover
architectures in such a way that the static refutational completeness
of a calculus immediately implies the dynamic  refutational
completeness of a prover implementing the calculus using a variant of
the given clause loop.  The technical report “A comprehensive
framework for saturation theorem proving” is available &lt;a
href=&#34;http://matryoshka.gforge.inria.fr/pubs/satur_report.pdf&#34;&gt;on
the Matryoshka website&lt;/a&gt;. The names of the Isabelle lemmas and
theorems corresponding to the results in the report are indicated in
the margin of the report.</description>
    </item>
    <item>
       <title>Formalization of an Optimized Monitoring Algorithm for Metric First-Order Dynamic Logic with Aggregations</title>
              <link>https://www.isa-afp.org/entries/MFODL_Monitor_Optimized.html</link>
       <guid>https://www.isa-afp.org/entries/MFODL_Monitor_Optimized.html</guid>
       <dc:creator> Thibault Dardinier, Lukas Heimes, Martin Raszyk, Joshua Schneider, Dmitriy Traytel       </dc:creator>
       <pubDate>09 Apr 2020 00:00:00 +0000</pubDate>
       <description>
A monitor is a runtime verification tool that solves the following
problem: Given a stream of time-stamped events and a policy formulated
in a specification language, decide whether the policy is satisfied at
every point in the stream. We verify the correctness of an executable
monitor for specifications given as formulas in metric first-order
dynamic logic (MFODL), which combines the features of metric
first-order temporal logic (MFOTL) and metric dynamic logic. Thus,
MFODL supports real-time constraints, first-order parameters, and
regular expressions. Additionally, the monitor supports aggregation
operations such as count and sum. This formalization, which is
described in a &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/ijcar20-verimonplus/verimonplus.pdf&#34;&gt;
forthcoming paper at IJCAR 2020&lt;/a&gt;, significantly extends &lt;a
href=&#34;https://www.isa-afp.org/entries/MFOTL_Monitor.html&#34;&gt;previous
work on a verified monitor&lt;/a&gt; for MFOTL. Apart from the
addition of regular expressions and aggregations, we implemented &lt;a
href=&#34;https://www.isa-afp.org/entries/Generic_Join.html&#34;&gt;multi-way
joins&lt;/a&gt; and a specialized sliding window algorithm to further
optimize the monitor.</description>
    </item>
    <item>
       <title>Lucas's Theorem</title>
              <link>https://www.isa-afp.org/entries/Lucas_Theorem.html</link>
       <guid>https://www.isa-afp.org/entries/Lucas_Theorem.html</guid>
       <dc:creator> Chelsea Edmonds       </dc:creator>
       <pubDate>07 Apr 2020 00:00:00 +0000</pubDate>
       <description>
This work presents a formalisation of a generating function proof for
Lucas&#39;s theorem. We first outline extensions to the existing
Formal Power Series (FPS) library, including an equivalence relation
for coefficients modulo &lt;em&gt;n&lt;/em&gt;, an alternate binomial theorem statement,
and a formalised proof of the Freshman&#39;s dream (mod &lt;em&gt;p&lt;/em&gt;) lemma.
The second part of the work presents the formal proof of Lucas&#39;s
Theorem. Working backwards, the formalisation first proves a well
known corollary of the theorem which is easier to formalise, and then
applies induction to prove the original theorem statement. The proof
of the corollary aims to provide a good example of a formalised
generating function equivalence proof using the FPS library. The final
theorem statement is intended to be integrated into the formalised
proof of Hilbert&#39;s 10th Problem.</description>
    </item>
    <item>
       <title>Strong Eventual Consistency of the Collaborative Editing Framework WOOT</title>
              <link>https://www.isa-afp.org/entries/WOOT_Strong_Eventual_Consistency.html</link>
       <guid>https://www.isa-afp.org/entries/WOOT_Strong_Eventual_Consistency.html</guid>
       <dc:creator> Emin Karayel, Edgar Gonzàlez       </dc:creator>
       <pubDate>25 Mar 2020 00:00:00 +0000</pubDate>
       <description>
Commutative Replicated Data Types (CRDTs) are a promising new class of
data structures for large-scale shared mutable content in applications
that only require eventual consistency. The WithOut Operational
Transforms (WOOT) framework is a CRDT for collaborative text editing
introduced by Oster et al. (CSCW 2006) for which the eventual
consistency property was verified only for a bounded model to date. We
contribute a formal proof for WOOTs strong eventual consistency.</description>
    </item>
    <item>
       <title>Furstenberg's topology and his proof of the infinitude of primes</title>
              <link>https://www.isa-afp.org/entries/Furstenberg_Topology.html</link>
       <guid>https://www.isa-afp.org/entries/Furstenberg_Topology.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>22 Mar 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article gives a formal version of Furstenberg&#39;s
topological proof of the infinitude of primes. He defines a topology
on the integers based on arithmetic progressions (or, equivalently,
residue classes). Using some fairly obvious properties of this
topology, the infinitude of primes is then easily obtained.&lt;/p&gt;
&lt;p&gt;Apart from this, this topology is also fairly ‘nice’ in
general: it is second countable, metrizable, and perfect. All of these
(well-known) facts are formally proven, including an explicit metric
for the topology given by Zulfeqarr.&lt;/p&gt;</description>
    </item>
    <item>
       <title>An Under-Approximate Relational Logic</title>
              <link>https://www.isa-afp.org/entries/Relational-Incorrectness-Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Relational-Incorrectness-Logic.html</guid>
       <dc:creator> Toby Murray       </dc:creator>
       <pubDate>12 Mar 2020 00:00:00 +0000</pubDate>
       <description>
Recently, authors have proposed under-approximate logics for reasoning
about programs. So far, all such logics have been confined to
reasoning about individual program behaviours. Yet there exist many
over-approximate relational logics for reasoning about pairs of
programs and relating their behaviours. We present the first
under-approximate relational logic, for the simple imperative language
IMP. We prove our logic is both sound and complete. Additionally, we
show how reasoning in this logic can be decomposed into non-relational
reasoning in an under-approximate Hoare logic, mirroring Beringer’s
result for over-approximate relational logics. We illustrate the
application of our logic on some small examples in which we provably
demonstrate the presence of insecurity.</description>
    </item>
    <item>
       <title>Hello World</title>
              <link>https://www.isa-afp.org/entries/Hello_World.html</link>
       <guid>https://www.isa-afp.org/entries/Hello_World.html</guid>
       <dc:creator> Cornelius Diekmann, Lars Hupel       </dc:creator>
       <pubDate>07 Mar 2020 00:00:00 +0000</pubDate>
       <description>
In this article, we present a formalization of the well-known
&#34;Hello, World!&#34; code, including a formal framework for
reasoning about IO. Our model is inspired by the handling of IO in
Haskell. We start by formalizing the 🌍 and embrace the IO monad
afterwards. Then we present a sample main :: IO (), followed by its
proof of correctness.</description>
    </item>
    <item>
       <title>Implementing the Goodstein Function in &lambda;-Calculus</title>
              <link>https://www.isa-afp.org/entries/Goodstein_Lambda.html</link>
       <guid>https://www.isa-afp.org/entries/Goodstein_Lambda.html</guid>
       <dc:creator> Bertram Felgenhauer       </dc:creator>
       <pubDate>21 Feb 2020 00:00:00 +0000</pubDate>
       <description>
In this formalization, we develop an implementation of the Goodstein
function G in plain &amp;lambda;-calculus, linked to a concise, self-contained
specification. The implementation works on a Church-encoded
representation of countable ordinals. The initial conversion to
hereditary base 2 is not covered, but the material is sufficient to
compute the particular value G(16), and easily extends to other fixed
arguments.</description>
    </item>
    <item>
       <title>A Generic Framework for Verified Compilers</title>
              <link>https://www.isa-afp.org/entries/VeriComp.html</link>
       <guid>https://www.isa-afp.org/entries/VeriComp.html</guid>
       <dc:creator> Martin Desharnais       </dc:creator>
       <pubDate>10 Feb 2020 00:00:00 +0000</pubDate>
       <description>
This is a generic framework for formalizing compiler transformations.
It leverages Isabelle/HOL’s locales to abstract over concrete
languages and transformations. It states common definitions for
language semantics, program behaviours, forward and backward
simulations, and compilers. We provide generic operations, such as
simulation and compiler composition, and prove general (partial)
correctness theorems, resulting in reusable proof components.</description>
    </item>
    <item>
       <title>Arithmetic progressions and relative primes</title>
              <link>https://www.isa-afp.org/entries/Arith_Prog_Rel_Primes.html</link>
       <guid>https://www.isa-afp.org/entries/Arith_Prog_Rel_Primes.html</guid>
       <dc:creator> José Manuel Rodríguez Caballero       </dc:creator>
       <pubDate>01 Feb 2020 00:00:00 +0000</pubDate>
       <description>
This article provides a formalization of the solution obtained by the
author of the Problem “ARITHMETIC PROGRESSIONS” from the
&lt;a href=&#34;https://www.ocf.berkeley.edu/~wwu/riddles/putnam.shtml&#34;&gt;
Putnam exam problems of 2002&lt;/a&gt;. The statement of the problem is
as follows: For which integers &lt;em&gt;n&lt;/em&gt; &gt; 1 does the set of positive
integers less than and relatively prime to &lt;em&gt;n&lt;/em&gt; constitute an
arithmetic progression?</description>
    </item>
    <item>
       <title>A Hierarchy of Algebras for Boolean Subsets</title>
              <link>https://www.isa-afp.org/entries/Subset_Boolean_Algebras.html</link>
       <guid>https://www.isa-afp.org/entries/Subset_Boolean_Algebras.html</guid>
       <dc:creator> Walter Guttmann, Bernhard Möller       </dc:creator>
       <pubDate>31 Jan 2020 00:00:00 +0000</pubDate>
       <description>
We present a collection of axiom systems for the construction of
Boolean subalgebras of larger overall algebras. The subalgebras are
defined as the range of a complement-like operation on a semilattice.
This technique has been used, for example, with the antidomain
operation, dynamic negation and Stone algebras. We present a common
ground for these constructions based on a new equational
axiomatisation of Boolean algebras.</description>
    </item>
    <item>
       <title>Mersenne primes and the Lucas–Lehmer test</title>
              <link>https://www.isa-afp.org/entries/Mersenne_Primes.html</link>
       <guid>https://www.isa-afp.org/entries/Mersenne_Primes.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>17 Jan 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides formal proofs of basic properties of
Mersenne numbers, i. e. numbers of the form
2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; - 1, and especially of
Mersenne primes.&lt;/p&gt; &lt;p&gt;In particular, an efficient,
verified, and executable version of the Lucas&amp;ndash;Lehmer test is
developed. This test decides primality for Mersenne numbers in time
polynomial in &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Verified Approximation Algorithms</title>
              <link>https://www.isa-afp.org/entries/Approximation_Algorithms.html</link>
       <guid>https://www.isa-afp.org/entries/Approximation_Algorithms.html</guid>
       <dc:creator> Robin Eßmann, Tobias Nipkow, Simon Robillard       </dc:creator>
       <pubDate>16 Jan 2020 00:00:00 +0000</pubDate>
       <description>
We present the first formal verification of approximation algorithms
for NP-complete optimization problems: vertex cover, independent set,
load balancing, and bin packing. The proofs correct incompletenesses
in existing proofs and improve the approximation ratio in one case.</description>
    </item>
    <item>
       <title>Closest Pair of Points Algorithms</title>
              <link>https://www.isa-afp.org/entries/Closest_Pair_Points.html</link>
       <guid>https://www.isa-afp.org/entries/Closest_Pair_Points.html</guid>
       <dc:creator> Martin Rau, Tobias Nipkow       </dc:creator>
       <pubDate>13 Jan 2020 00:00:00 +0000</pubDate>
       <description>
This entry provides two related verified divide-and-conquer algorithms
solving the fundamental &lt;em&gt;Closest Pair of Points&lt;/em&gt;
problem in Computational Geometry. Functional correctness and the
optimal running time of &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;) are
proved. Executable code is generated which is empirically competitive
with handwritten reference implementations.</description>
    </item>
    <item>
       <title>Skip Lists</title>
              <link>https://www.isa-afp.org/entries/Skip_Lists.html</link>
       <guid>https://www.isa-afp.org/entries/Skip_Lists.html</guid>
       <dc:creator> Max W. Haslbeck, Manuel Eberl       </dc:creator>
       <pubDate>09 Jan 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt; Skip lists are sorted linked lists enhanced with shortcuts
and are an alternative to binary search trees. A skip lists consists
of multiple levels of sorted linked lists where a list on level n is a
subsequence of the list on level n − 1. In the ideal case, elements
are skipped in such a way that a lookup in a skip lists takes O(log n)
time. In a randomised skip list the skipped elements are choosen
randomly. &lt;/p&gt; &lt;p&gt; This entry contains formalized proofs
of the textbook results about the expected height and the expected
length of a search path in a randomised skip list. &lt;/p&gt;</description>
    </item>
    <item>
       <title>Bicategories</title>
              <link>https://www.isa-afp.org/entries/Bicategory.html</link>
       <guid>https://www.isa-afp.org/entries/Bicategory.html</guid>
       <dc:creator> Eugene W. Stark       </dc:creator>
       <pubDate>06 Jan 2020 00:00:00 +0000</pubDate>
       <description>
Taking as a starting point the author&#39;s previous work on
developing aspects of category theory in Isabelle/HOL, this article
gives a compatible formalization of the notion of
&#34;bicategory&#34; and develops a framework within which formal
proofs of facts about bicategories can be given.  The framework
includes a number of basic results, including the Coherence Theorem,
the Strictness Theorem, pseudofunctors and biequivalence, and facts
about internal equivalences and adjunctions in a bicategory.  As a
driving application and demonstration of the utility of the framework,
it is used to give a formal proof of a theorem, due to Carboni,
Kasangian, and Street, that characterizes up to biequivalence the
bicategories of spans in a category with pullbacks.  The formalization
effort necessitated the filling-in of many details that were not
evident from the brief presentation in the original paper, as well as
identifying a few minor corrections along the way.</description>
    </item>
    <item>
       <title>The Irrationality of ζ(3)</title>
              <link>https://www.isa-afp.org/entries/Zeta_3_Irrational.html</link>
       <guid>https://www.isa-afp.org/entries/Zeta_3_Irrational.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>27 Dec 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides a formalisation of Beukers&#39;s
straightforward analytic proof that ζ(3) is irrational. This was first
proven by Apéry (which is why this result is also often called
‘Apéry&#39;s Theorem’) using a more algebraic approach. This
formalisation follows &lt;a
href=&#34;http://people.math.sc.edu/filaseta/gradcourses/Math785/Math785Notes4.pdf&#34;&gt;Filaseta&#39;s
presentation&lt;/a&gt; of Beukers&#39;s proof.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Formalizing a Seligman-Style Tableau System for Hybrid Logic</title>
              <link>https://www.isa-afp.org/entries/Hybrid_Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Hybrid_Logic.html</guid>
       <dc:creator> Asta Halkjær From       </dc:creator>
       <pubDate>20 Dec 2019 00:00:00 +0000</pubDate>
       <description>
This work is a formalization of soundness and completeness proofs
for a Seligman-style tableau system for hybrid logic. The completeness
result is obtained via a synthetic approach using maximally
consistent sets of tableau blocks. The formalization differs from
the cited work in a few ways. First, to avoid the need to backtrack in
the construction of a tableau, the formalized system has no unnamed
initial segment, and therefore no Name rule. Second, I show that the
full Bridge rule is admissible in the system. Third, I start from rules
restricted to only extend the branch with new formulas, including only
witnessing diamonds that are not already witnessed, and show that
the unrestricted rules are admissible. Similarly, I start from simpler
versions of the @-rules and show the general ones admissible. Finally,
the GoTo rule is restricted using a notion of coins such that each
application consumes a coin and coins are earned through applications of
the remaining rules. I show that if a branch can be closed then it can
be closed starting from a single coin. These restrictions are imposed
to rule out some means of nontermination.</description>
    </item>
    <item>
       <title>The Poincaré-Bendixson Theorem</title>
              <link>https://www.isa-afp.org/entries/Poincare_Bendixson.html</link>
       <guid>https://www.isa-afp.org/entries/Poincare_Bendixson.html</guid>
       <dc:creator> Fabian Immler, Yong Kiam Tan       </dc:creator>
       <pubDate>18 Dec 2019 00:00:00 +0000</pubDate>
       <description>
The Poincaré-Bendixson theorem is a classical result in the study of
(continuous) dynamical systems. Colloquially, it restricts the
possible behaviors of planar dynamical systems: such systems cannot be
chaotic. In practice, it is a useful tool for proving the existence of
(limiting) periodic behavior in planar systems. The theorem is an
interesting and challenging benchmark for formalized mathematics
because proofs in the literature rely on geometric sketches and only
hint at symmetric cases. It also requires a substantial background of
mathematical theories, e.g., the Jordan curve theorem, real analysis,
ordinary differential equations, and limiting (long-term) behavior of
dynamical systems.</description>
    </item>
    <item>
       <title>Poincaré Disc Model</title>
              <link>https://www.isa-afp.org/entries/Poincare_Disc.html</link>
       <guid>https://www.isa-afp.org/entries/Poincare_Disc.html</guid>
       <dc:creator> Danijela Simić, Filip Marić, Pierre Boutry       </dc:creator>
       <pubDate>16 Dec 2019 00:00:00 +0000</pubDate>
       <description>
We describe formalization of the Poincaré disc model of hyperbolic
geometry within the Isabelle/HOL proof assistant. The model is defined
within the extended complex plane (one dimensional complex projectives
space &amp;#8450;P1), formalized in the AFP entry “Complex Geometry”.
Points, lines, congruence of pairs of points, betweenness of triples
of points, circles, and isometries are defined within the model. It is
shown that the model satisfies all Tarski&#39;s axioms except the
Euclid&#39;s axiom. It is shown that it satisfies its negation and
the limiting parallels axiom (which proves it to be a model of
hyperbolic geometry).</description>
    </item>
    <item>
       <title>Complex Geometry</title>
              <link>https://www.isa-afp.org/entries/Complex_Geometry.html</link>
       <guid>https://www.isa-afp.org/entries/Complex_Geometry.html</guid>
       <dc:creator> Filip Marić, Danijela Simić       </dc:creator>
       <pubDate>16 Dec 2019 00:00:00 +0000</pubDate>
       <description>
A formalization of geometry of complex numbers is presented.
Fundamental objects that are investigated are the complex plane
extended by a single infinite point, its objects (points, lines and
circles), and groups of transformations that act on them (e.g.,
inversions and Möbius transformations). Most objects are defined
algebraically, but correspondence with classical geometric definitions
is shown.</description>
    </item>
    <item>
       <title>Gauss Sums and the Pólya–Vinogradov Inequality</title>
              <link>https://www.isa-afp.org/entries/Gauss_Sums.html</link>
       <guid>https://www.isa-afp.org/entries/Gauss_Sums.html</guid>
       <dc:creator> Rodrigo Raya, Manuel Eberl       </dc:creator>
       <pubDate>10 Dec 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides a full formalisation of Chapter 8 of
Apostol&#39;s &lt;em&gt;&lt;a
href=&#34;https://www.springer.com/de/book/9780387901633&#34;&gt;Introduction
to Analytic Number Theory&lt;/a&gt;&lt;/em&gt;. Subjects that are
covered are:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;periodic arithmetic
functions and their finite Fourier series&lt;/li&gt;
&lt;li&gt;(generalised) Ramanujan sums&lt;/li&gt; &lt;li&gt;Gauss sums
and separable characters&lt;/li&gt; &lt;li&gt;induced moduli and
primitive characters&lt;/li&gt; &lt;li&gt;the
Pólya&amp;mdash;Vinogradov inequality&lt;/li&gt; &lt;/ul&gt;</description>
    </item>
    <item>
       <title>An Efficient Generalization of Counting Sort for Large, possibly Infinite Key Ranges</title>
              <link>https://www.isa-afp.org/entries/Generalized_Counting_Sort.html</link>
       <guid>https://www.isa-afp.org/entries/Generalized_Counting_Sort.html</guid>
       <dc:creator> Pasquale Noce       </dc:creator>
       <pubDate>04 Dec 2019 00:00:00 +0000</pubDate>
       <description>
Counting sort is a well-known algorithm that sorts objects of any kind
mapped to integer keys, or else to keys in one-to-one correspondence
with some subset of the integers (e.g. alphabet letters). However, it
is suitable for direct use, viz. not just as a subroutine of another
sorting algorithm (e.g. radix sort), only if the key range is not
significantly larger than the number of the objects to be sorted.
This paper describes a tail-recursive generalization of counting sort
making use of a bounded number of counters, suitable for direct use in
case of a large, or even infinite key range of any kind, subject to
the only constraint of being a subset of an arbitrary linear order.
After performing a pen-and-paper analysis of how such algorithm has to
be designed to maximize its efficiency, this paper formalizes the
resulting generalized counting sort (GCsort) algorithm and then
formally proves its correctness properties, namely that (a) the
counters&#39; number is maximized never exceeding the fixed upper
bound, (b) objects are conserved, (c) objects get sorted, and (d) the
algorithm is stable.</description>
    </item>
    <item>
       <title>Interval Arithmetic on 32-bit Words</title>
              <link>https://www.isa-afp.org/entries/Interval_Arithmetic_Word32.html</link>
       <guid>https://www.isa-afp.org/entries/Interval_Arithmetic_Word32.html</guid>
       <dc:creator> Brandon Bohrer       </dc:creator>
       <pubDate>27 Nov 2019 00:00:00 +0000</pubDate>
       <description>
Interval_Arithmetic implements conservative interval arithmetic
computations, then uses this interval arithmetic to implement a simple
programming language where all terms have 32-bit signed word values,
with explicit infinities for terms outside the representable bounds.
Our target use case is interpreters for languages that must have a
well-understood low-level behavior.  We include a formalization of
bounded-length strings which are used for the identifiers of our
language. Bounded-length identifiers are useful in some applications,
for example the &lt;a href=&#34;https://www.isa-afp.org/entries/Differential_Dynamic_Logic.html&#34;&gt;Differential_Dynamic_Logic&lt;/a&gt; article,
where a Euclidean space indexed by identifiers demands that identifiers
are finitely many.</description>
    </item>
    <item>
       <title>Zermelo Fraenkel Set Theory in Higher-Order Logic</title>
              <link>https://www.isa-afp.org/entries/ZFC_in_HOL.html</link>
       <guid>https://www.isa-afp.org/entries/ZFC_in_HOL.html</guid>
       <dc:creator> Lawrence C. Paulson       </dc:creator>
       <pubDate>24 Oct 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry is a new formalisation of ZFC set theory in Isabelle/HOL. It is
logically equivalent to Obua&#39;s HOLZF; the point is to have the closest
possible integration with the rest of Isabelle/HOL, minimising the amount of
new notations and exploiting type classes.&lt;/p&gt;
&lt;p&gt;There is a type &lt;em&gt;V&lt;/em&gt; of sets and a function &lt;em&gt;elts :: V =&amp;gt; V
set&lt;/em&gt; mapping a set to its elements. Classes simply have type &lt;em&gt;V
set&lt;/em&gt;, and a predicate identifies the small classes: those that correspond
to actual sets. Type classes connected with orders and lattices are used to
minimise the amount of new notation for concepts such as the subset relation,
union and intersection. Basic concepts — Cartesian products, disjoint sums,
natural numbers, functions, etc. — are formalised.&lt;/p&gt;
&lt;p&gt;More advanced set-theoretic concepts, such as transfinite induction,
ordinals, cardinals and the transitive closure of a set, are also provided.
The definition of addition and multiplication for general sets (not just
ordinals) follows Kirby.&lt;/p&gt;
&lt;p&gt;The theory provides two type classes with the aim of facilitating
developments that combine &lt;em&gt;V&lt;/em&gt; with other Isabelle/HOL types:
&lt;em&gt;embeddable&lt;/em&gt;, the class of types that can be injected into &lt;em&gt;V&lt;/em&gt;
(including &lt;em&gt;V&lt;/em&gt; itself as well as &lt;em&gt;V*V&lt;/em&gt;, etc.), and
&lt;em&gt;small&lt;/em&gt;, the class of types that correspond to some ZF set.&lt;/p&gt;
extra-history =
Change history:
[2020-01-28]:  Generalisation of the &#34;small&#34; predicate and order types to arbitrary sets;
ordinal exponentiation;
introduction of the coercion ord_of_nat :: &#34;nat =&gt; V&#34;;
numerous new lemmas. (revision 6081d5be8d08)</description>
    </item>
    <item>
       <title>Isabelle/C</title>
              <link>https://www.isa-afp.org/entries/Isabelle_C.html</link>
       <guid>https://www.isa-afp.org/entries/Isabelle_C.html</guid>
       <dc:creator> Frédéric Tuong, Burkhart Wolff       </dc:creator>
       <pubDate>22 Oct 2019 00:00:00 +0000</pubDate>
       <description>
We present a framework for C code in C11 syntax deeply integrated into
the Isabelle/PIDE development environment. Our framework provides an
abstract interface for verification back-ends to be plugged-in
independently. Thus, various techniques such as deductive program
verification or white-box testing can be applied to the same source,
which is part of an integrated PIDE document model. Semantic back-ends
are free to choose the supported C fragment and its semantics. In
particular, they can differ on the chosen memory model or the
specification mechanism for framing conditions. Our framework supports
semantic annotations of C sources in the form of comments. Annotations
serve to locally control back-end settings, and can express the term
focus to which an annotation refers. Both the logical and the
syntactic context are available when semantic annotations are
evaluated. As a consequence, a formula in an annotation can refer both
to HOL or C variables. Our approach demonstrates the degree of
maturity and expressive power the Isabelle/PIDE sub-system has
achieved in recent years. Our integration technique employs Lex and
Yacc style grammars to ensure efficient deterministic parsing.  This
is the core-module of Isabelle/C; the AFP package for Clean and
Clean_wrapper as well as AutoCorres and AutoCorres_wrapper (available
via git) are applications of this front-end.</description>
    </item>
    <item>
       <title>VerifyThis 2019 -- Polished Isabelle Solutions</title>
              <link>https://www.isa-afp.org/entries/VerifyThis2019.html</link>
       <guid>https://www.isa-afp.org/entries/VerifyThis2019.html</guid>
       <dc:creator> Peter Lammich, Simon Wimmer       </dc:creator>
       <pubDate>16 Oct 2019 00:00:00 +0000</pubDate>
       <description>
VerifyThis 2019 (http://www.pm.inf.ethz.ch/research/verifythis.html)
was a program verification competition associated with ETAPS 2019. It
was the 8th event in the VerifyThis competition series. In this entry,
we present polished and completed versions of our solutions that we
created during the competition.</description>
    </item>
  </channel>
</rss>
