<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>08 Apr 2022 00:00:00 +0000</pubDate>
    <item>
       <title>A Combinator Library for Prefix-Free Codes</title>
              <link>https://www.isa-afp.org/entries/Prefix_Free_Code_Combinators.html</link>
       <guid>https://www.isa-afp.org/entries/Prefix_Free_Code_Combinators.html</guid>
       <dc:creator> Emin Karayel       </dc:creator>
       <pubDate>08 Apr 2022 00:00:00 +0000</pubDate>
       <description>
This entry contains a set of binary encodings for primitive data
types, such as natural numbers, integers, floating-point numbers as
well as combinators to construct encodings for products, lists, sets
or functions of/between such types.  For natural numbers and integers,
the entry contains various encodings, such as Elias-Gamma-Codes and
exponential Golomb Codes, which are efficient variable-length codes in
use by current compression formats.  A use-case for this library is
measuring the persisted size of a complex data structure without
having to hand-craft a dedicated encoding for it, independent of
Isabelle&#39;s internal representation.</description>
    </item>
    <item>
       <title>Constructing the Reals as Dedekind Cuts of Rationals</title>
              <link>https://www.isa-afp.org/entries/Dedekind_Real.html</link>
       <guid>https://www.isa-afp.org/entries/Dedekind_Real.html</guid>
       <dc:creator> Jacques D. Fleuriot, Lawrence C. Paulson       </dc:creator>
       <pubDate>24 Mar 2022 00:00:00 +0000</pubDate>
       <description>
The type of real numbers is constructed from the positive rationals
using the method of Dedekind cuts. This development, briefly described
in papers by the authors, follows the textbook presentation by
Gleason. It&#39;s notable that the first formalisation of a
significant piece of mathematics, by Jutting in 1977, involved a
similar construction.</description>
    </item>
    <item>
       <title>Ackermann's Function Is Not Primitive Recursive</title>
              <link>https://www.isa-afp.org/entries/Ackermanns_not_PR.html</link>
       <guid>https://www.isa-afp.org/entries/Ackermanns_not_PR.html</guid>
       <dc:creator> Lawrence C. Paulson       </dc:creator>
       <pubDate>23 Mar 2022 00:00:00 +0000</pubDate>
       <description>
Ackermann&#39;s function is defined in the usual way and a number of
its elementary properties are proved. Then, the primitive recursive
functions are defined inductively: as a predicate on the functions
that map lists of  numbers to numbers. It is shown that every
primitive recursive function is strictly dominated by Ackermann&#39;s
function. The formalisation follows an earlier one by Nora Szasz.</description>
    </item>
    <item>
       <title>A Naive Prover for First-Order Logic</title>
              <link>https://www.isa-afp.org/entries/FOL_Seq_Calc3.html</link>
       <guid>https://www.isa-afp.org/entries/FOL_Seq_Calc3.html</guid>
       <dc:creator> Asta Halkjær From       </dc:creator>
       <pubDate>22 Mar 2022 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt; The AFP entry &lt;a
href=&#34;https://www.isa-afp.org/entries/Abstract_Completeness.html&#34;&gt;Abstract
Completeness&lt;/a&gt; by Blanchette, Popescu and Traytel formalizes
the core of Beth/Hintikka-style completeness proofs for first-order
logic and can be used to formalize executable sequent calculus
provers. In the Journal of Automated Reasoning, the authors
instantiate the framework with a sequent calculus for first-order
logic and prove its completeness. Their use of an infinite set of
proof rules indexed by formulas yields very direct arguments. A fair
stream of these rules controls the prover, making its definition
remarkably simple. The AFP entry, however, only contains a toy example
for propositional logic. The AFP entry &lt;a
href=&#34;https://www.isa-afp.org/entries/FOL_Seq_Calc2.html&#34;&gt;A
Sequent Calculus Prover for First-Order Logic with Functions&lt;/a&gt;
by From and Jacobsen also uses the framework, but uses a finite set of
generic rules resulting in a more sophisticated prover with more
complicated proofs. &lt;/p&gt; &lt;p&gt; This entry contains an
executable sequent calculus prover for first-order logic with
functions in the style presented by Blanchette et al. The prover can
be exported to Haskell and this entry includes formalized proofs of
its soundness and completeness. The proofs are simpler than those for
the prover by From and Jacobsen but the performance of the prover is
significantly worse. &lt;/p&gt; &lt;p&gt; The included theory
&lt;em&gt;Fair-Stream&lt;/em&gt; first proves that the sequence of
natural numbers 0, 0, 1, 0, 1, 2, etc. is fair. It then proves that
mapping any surjective function across the sequence preserves
fairness. This method of obtaining a fair stream of rules is similar
to the one given by Blanchette et al. The concrete functions from
natural numbers to terms, formulas and rules are defined using the
&lt;em&gt;Nat-Bijection&lt;/em&gt; theory in the HOL-Library.
&lt;/p&gt;</description>
    </item>
    <item>
       <title>A Proof from THE BOOK: The Partial Fraction Expansion of the Cotangent</title>
              <link>https://www.isa-afp.org/entries/Cotangent_PFD_Formula.html</link>
       <guid>https://www.isa-afp.org/entries/Cotangent_PFD_Formula.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>15 Mar 2022 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;In this article, I formalise a proof from &lt;a
href=&#34;https://dx.doi.org/10.1007/978-3-662-57265-8&#34;&gt;THE
BOOK&lt;/a&gt;; namely a formula that was called ‘one of the most
beautiful formulas involving elementary functions’:&lt;/p&gt; \[\pi
\cot(\pi z) = \frac{1}{z} + \sum_{n=1}^\infty\left(\frac{1}{z+n} +
\frac{1}{z-n}\right)\] &lt;p&gt;The proof uses Herglotz&#39;s trick
to show the real case and analytic continuation for the complex
case.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Independence of the Continuum Hypothesis in Isabelle/ZF</title>
              <link>https://www.isa-afp.org/entries/Independence_CH.html</link>
       <guid>https://www.isa-afp.org/entries/Independence_CH.html</guid>
       <dc:creator> Emmanuel Gunther, Miguel Pagano, Pedro Sánchez Terraf, and Matías Steinberg       </dc:creator>
       <pubDate>06 Mar 2022 00:00:00 +0000</pubDate>
       <description>
We redeveloped our formalization of forcing in the set theory
framework of Isabelle/ZF. Under the assumption of the existence of a
countable transitive model of ZFC, we construct proper generic
extensions that satisfy the Continuum Hypothesis and its negation.</description>
    </item>
    <item>
       <title>Transitive Models of Fragments of ZFC</title>
              <link>https://www.isa-afp.org/entries/Transitive_Models.html</link>
       <guid>https://www.isa-afp.org/entries/Transitive_Models.html</guid>
       <dc:creator> Emmanuel Gunther, Miguel Pagano, Pedro Sánchez Terraf, and Matías Steinberg       </dc:creator>
       <pubDate>03 Mar 2022 00:00:00 +0000</pubDate>
       <description>
We extend the ZF-Constructibility library by relativizing theories of
the Isabelle/ZF and Delta System Lemma sessions to a transitive class.
We also relativize Paulson&#39;s work on Aleph and our former
treatment of the Axiom of Dependent Choices. This work is a
prerrequisite to our formalization of the independence of the
Continuum Hypothesis.</description>
    </item>
    <item>
       <title>Residuated Transition Systems</title>
              <link>https://www.isa-afp.org/entries/ResiduatedTransitionSystem.html</link>
       <guid>https://www.isa-afp.org/entries/ResiduatedTransitionSystem.html</guid>
       <dc:creator> Eugene W. Stark       </dc:creator>
       <pubDate>28 Feb 2022 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt; A &lt;em&gt;residuated transition system&lt;/em&gt; (RTS) is
a transition system that is equipped with a certain partial binary
operation, called &lt;em&gt;residuation&lt;/em&gt;, on transitions.
Using the residuation operation, one can express nuances, such as a
distinction between nondeterministic and concurrent choice, as well as
partial commutativity relationships between transitions, which are not
captured by ordinary transition systems. A version of residuated
transition systems was introduced in previous work by the author, in
which they were called “concurrent transition systems” in view of the
original motivation for their definition from the study of
concurrency. In the first part of the present article, we give a
formal development that generalizes and subsumes the original
presentation. We give an axiomatic definition of residuated transition
systems that assumes only a single partial binary operation as given
structure. From the axioms, we derive notions of “arrow“ (transition),
“source”, “target”, “identity”, as well as “composition” and “join” of
transitions; thereby recovering structure that in the previous work
was assumed as given. We formalize and generalize the result, that
residuation extends from transitions to transition paths, and we
systematically develop the properties of this extension. A significant
generalization made in the present work is the identification of a
general notion of congruence on RTS’s, along with an associated
quotient construction. &lt;/p&gt; &lt;p&gt; In the second part of this
article, we use the RTS framework to formalize several results in the
theory of reduction in Church’s λ-calculus. Using a de Bruijn
index-based syntax in which terms represent parallel reduction steps,
we define residuation on terms and show that it satisfies the axioms
for an RTS. An application of the results on paths from the first part
of the article allows us to prove the classical Church-Rosser Theorem
with little additional effort. We then use residuation to define the
notion of “development” and we prove the Finite Developments Theorem,
that every development is finite, formalizing and adapting to de
Bruijn indices a proof by de Vrijer. We also use residuation to define
the notion of a “standard reduction path”, and we prove the
Standardization Theorem: that every reduction path is congruent to a
standard one. As a corollary of the Standardization Theorem, we obtain
the Leftmost Reduction Theorem: that leftmost reduction is a
normalizing strategy. &lt;/p&gt;</description>
    </item>
    <item>
       <title>Universal Hash Families</title>
              <link>https://www.isa-afp.org/entries/Universal_Hash_Families.html</link>
       <guid>https://www.isa-afp.org/entries/Universal_Hash_Families.html</guid>
       <dc:creator> Emin Karayel       </dc:creator>
       <pubDate>20 Feb 2022 00:00:00 +0000</pubDate>
       <description>
A &lt;i&gt;k&lt;/i&gt;-universal hash family is a probability
space of functions, which have uniform distribution and form
&lt;i&gt;k&lt;/i&gt;-wise independent random variables. They can often be used
in place of classic (or cryptographic) hash functions and allow the
rigorous analysis of the performance of randomized algorithms and
data structures that rely on hash functions. In 1981
&lt;a href=&#34;https://doi.org/10.1016/0022-0000(81)90033-7&#34;&gt;Wegman and Carter&lt;/a&gt;
introduced a generic construction for such families with arbitrary
&lt;i&gt;k&lt;/i&gt; using polynomials over a finite field. This entry
contains a formalization of them and establishes the property of
&lt;i&gt;k&lt;/i&gt;-universality. To be useful the formalization also provides
an explicit construction of finite fields using the factor ring of
integers modulo a prime. Additionally, some generic results about
independent families are shown that might be of independent interest.</description>
    </item>
    <item>
       <title>Wetzel's Problem and the Continuum Hypothesis</title>
              <link>https://www.isa-afp.org/entries/Wetzels_Problem.html</link>
       <guid>https://www.isa-afp.org/entries/Wetzels_Problem.html</guid>
       <dc:creator> Lawrence C Paulson       </dc:creator>
       <pubDate>18 Feb 2022 00:00:00 +0000</pubDate>
       <description>
Let $F$ be a set of analytic functions on the complex plane such that,
for each $z\in\mathbb{C}$, the set $\{f(z) \mid f\in F\}$ is
countable; must then $F$ itself be countable? The answer is yes if the
Continuum Hypothesis is false, i.e., if the cardinality of
$\mathbb{R}$ exceeds $\aleph_1$. But if CH is true then such an $F$,
of cardinality $\aleph_1$, can be constructed by transfinite
recursion.  The formal proof illustrates reasoning about complex
analysis (analytic and homomorphic functions) and set theory
(transfinite cardinalities) in a single setting. The mathematical text
comes from &lt;em&gt;Proofs from THE BOOK&lt;/em&gt; by Aigner and
Ziegler.</description>
    </item>
    <item>
       <title>First-Order Query Evaluation</title>
              <link>https://www.isa-afp.org/entries/Eval_FO.html</link>
       <guid>https://www.isa-afp.org/entries/Eval_FO.html</guid>
       <dc:creator> Martin Raszyk       </dc:creator>
       <pubDate>15 Feb 2022 00:00:00 +0000</pubDate>
       <description>
We formalize first-order query evaluation over an infinite domain with
equality. We first define the syntax and semantics of first-order
logic with equality. Next we define a locale
&lt;i&gt;eval&amp;lowbar;fo&lt;/i&gt; abstracting a representation of
a potentially infinite set of tuples satisfying a first-order query
over finite relations. Inside the locale, we define a function
&lt;i&gt;eval&lt;/i&gt; checking if the set of tuples satisfying a
first-order query over a database (an interpretation of the
query&#39;s predicates) is finite (i.e., deciding &lt;i&gt;relative
safety&lt;/i&gt;) and computing the set of satisfying tuples if it is
finite. Altogether the function &lt;i&gt;eval&lt;/i&gt; solves
&lt;i&gt;capturability&lt;/i&gt; (Avron and Hirshfeld, 1991) of
first-order logic with equality. We also use the function
&lt;i&gt;eval&lt;/i&gt; to prove a code equation for the semantics of
first-order logic, i.e., the function checking if a first-order query
over a database is satisfied by a variable assignment.&lt;br/&gt; We provide an
interpretation of the locale &lt;i&gt;eval&amp;lowbar;fo&lt;/i&gt;
based on the approach by Ailamazyan et al. A core notion in the
interpretation is the active domain of a query and a database that
contains all domain elements that occur in the database or interpret
the query&#39;s constants. We prove the main theorem of Ailamazyan et
al. relating the satisfaction of a first-order query over an infinite
domain to the satisfaction of this query over a finite domain
consisting of the active domain and a few additional domain elements
(outside the active domain) whose number only depends on the query. In
our interpretation of the locale
&lt;i&gt;eval&amp;lowbar;fo&lt;/i&gt;, we use a potentially higher
number of the additional domain elements, but their number still only
depends on the query and thus has no effect on the data complexity
(Vardi, 1982) of query evaluation. Our interpretation yields an
&lt;i&gt;executable&lt;/i&gt; function &lt;i&gt;eval&lt;/i&gt;. The
time complexity of &lt;i&gt;eval&lt;/i&gt; on a query is linear in the
total number of tuples in the intermediate relations for the
subqueries. Specifically, we build a database index to evaluate a
conjunction. We also optimize the case of a negated subquery in a
conjunction. Finally, we export code for the infinite domain of
natural numbers.</description>
    </item>
    <item>
       <title>Multi-Head Monitoring of Metric Dynamic Logic</title>
              <link>https://www.isa-afp.org/entries/VYDRA_MDL.html</link>
       <guid>https://www.isa-afp.org/entries/VYDRA_MDL.html</guid>
       <dc:creator> Martin Raszyk       </dc:creator>
       <pubDate>13 Feb 2022 00:00:00 +0000</pubDate>
       <description>
Runtime monitoring (or runtime verification) is an approach to
checking compliance of a system&#39;s execution with a specification
(e.g., a temporal query). The system&#39;s execution is logged into a
trace---a sequence of time-points, each consisting of a time-stamp and
observed events. A monitor is an algorithm that produces verdicts on
the satisfaction of a temporal query on a trace.  We formalize a
monitoring algorithm for metric dynamic logic, an extension of metric
temporal logic with regular expressions. The monitor computes whether
a given query is satisfied at every position in an input trace of
time-stamped events. We formalize the time-stamps as an abstract
algebraic structure satisfying certain assumptions. Instances of this
structure include natural numbers, real numbers, and lexicographic
combinations of them. Our monitor follows the multi-head paradigm: it
reads the input simultaneously at multiple positions and moves its
reading heads asynchronously. This mode of operation results in
unprecedented time and space complexity guarantees for metric dynamic
logic: The monitor&#39;s amortized time complexity to process a
time-point and the monitor&#39;s space complexity neither depends on
the event-rate, i.e., the number of events within a fixed time-unit,
nor on the numeric constants occurring in the quantitative temporal
constraints in the given query.  The multi-head monitoring algorithm
for metric dynamic logic is reported in our paper &#34;Multi-Head
Monitoring of Metric Dynamic Logic&#34; published at ATVA 2020. We
have also formalized unpublished specialized algorithms for the
temporal operators of metric temporal logic.</description>
    </item>
    <item>
       <title>Enumeration of Equivalence Relations</title>
              <link>https://www.isa-afp.org/entries/Equivalence_Relation_Enumeration.html</link>
       <guid>https://www.isa-afp.org/entries/Equivalence_Relation_Enumeration.html</guid>
       <dc:creator> Emin Karayel       </dc:creator>
       <pubDate>04 Feb 2022 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry contains a formalization of an algorithm
enumerating all equivalence relations on an initial segment of the
natural numbers. The approach follows the method described by Stanton
and White &lt;a
href=&#34;https://doi.org/10.1007/978-1-4612-4968-9&#34;&gt;[5,§
1.5]&lt;/a&gt; using restricted growth functions.&lt;/p&gt;
&lt;p&gt;The algorithm internally enumerates restricted growth
functions (as lists), whose equivalence kernels then form the
equivalence relations. This has the advantage that the representation
is compact and lookup of the relation reduces to a list lookup
operation.&lt;/p&gt; &lt;p&gt;The algorithm can also be used within a
proof and an example application is included, where a sequence of
variables is split by the possible partitions they can form.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Quasi-Borel Spaces</title>
              <link>https://www.isa-afp.org/entries/Quasi_Borel_Spaces.html</link>
       <guid>https://www.isa-afp.org/entries/Quasi_Borel_Spaces.html</guid>
       <dc:creator> Michikazu Hirata, Yasuhiko Minamide, Tetsuya Sato       </dc:creator>
       <pubDate>03 Feb 2022 00:00:00 +0000</pubDate>
       <description>
The notion of quasi-Borel spaces was introduced by &lt;a
href=&#34;https://dl.acm.org/doi/10.5555/3329995.3330072&#34;&gt;
Heunen et al&lt;/a&gt;. The theory provides a suitable
denotational model for higher-order probabilistic programming
languages with continuous distributions. This entry is a formalization
of the theory of quasi-Borel spaces, including construction of
quasi-Borel spaces (product, coproduct, function spaces), the
adjunction between the category of measurable spaces and the category
of quasi-Borel spaces, and the probability monad on quasi-Borel
spaces. This entry also contains the formalization of the Bayesian
regression presented in the work of Heunen et al. This work is a part
of the work by same authors, &lt;i&gt;Program Logic for Higher-Order
Probabilistic Programs in Isabelle/HOL&lt;/i&gt;, which will be
published in the proceedings of the 16th International Symposium on
Functional and Logic Programming (FLOPS 2022).</description>
    </item>
    <item>
       <title>Duality of Linear Programming</title>
              <link>https://www.isa-afp.org/entries/LP_Duality.html</link>
       <guid>https://www.isa-afp.org/entries/LP_Duality.html</guid>
       <dc:creator> René Thiemann       </dc:creator>
       <pubDate>03 Feb 2022 00:00:00 +0000</pubDate>
       <description>
We formalize the weak and strong duality theorems of linear
programming. For the strong duality theorem we provide three
sufficient preconditions: both the primal problem and the dual problem
are satisfiable, the primal problem is satisfiable and bounded, or the
dual problem is satisfiable and bounded. The proofs are based on an
existing formalization of Farkas&#39; Lemma.</description>
    </item>
    <item>
       <title>First-Order Theory of Rewriting</title>
              <link>https://www.isa-afp.org/entries/FO_Theory_Rewriting.html</link>
       <guid>https://www.isa-afp.org/entries/FO_Theory_Rewriting.html</guid>
       <dc:creator> Alexander Lochmann, Bertram Felgenhauer       </dc:creator>
       <pubDate>02 Feb 2022 00:00:00 +0000</pubDate>
       <description>
The first-order theory of rewriting (FORT) is a decidable theory for
linear variable-separated rewrite systems. The decision procedure is
based on tree automata technique and an inference system presented in
&#34;Certifying Proofs in the First-Order Theory of Rewriting&#34;.
This AFP entry provides a formalization of the underlying decision
procedure. Moreover it allows to generate a function that can verify
each inference step via the code generation facility of Isabelle/HOL.
Additionally it contains the specification of a certificate language
(that allows to state proofs in FORT) and a formalized function that
allows to verify the validity of the proof. This gives software tool
authors, that implement the decision procedure, the possibility to
verify their output.</description>
    </item>
    <item>
       <title>Young's Inequality for Increasing Functions</title>
              <link>https://www.isa-afp.org/entries/Youngs_Inequality.html</link>
       <guid>https://www.isa-afp.org/entries/Youngs_Inequality.html</guid>
       <dc:creator> Lawrence C Paulson       </dc:creator>
       <pubDate>31 Jan 2022 00:00:00 +0000</pubDate>
       <description>
Young&#39;s inequality states that $$ ab \leq \int_0^a f(x)dx +
\int_0^b f^{-1}(y) dy $$ where $a\geq 0$, $b\geq 0$ and $f$ is
strictly increasing and continuous. Its proof is formalised following
&lt;a href=&#34;https://www.jstor.org/stable/2318018&#34;&gt;the
development&lt;/a&gt; by Cunningham and Grossman. Their idea is to
make the intuitive, geometric folklore proof rigorous by reasoning
about step functions. The lack of the Riemann integral makes the
development longer than one would like, but their argument is
reproduced faithfully.</description>
    </item>
    <item>
       <title>A Sequent Calculus Prover for First-Order Logic with Functions</title>
              <link>https://www.isa-afp.org/entries/FOL_Seq_Calc2.html</link>
       <guid>https://www.isa-afp.org/entries/FOL_Seq_Calc2.html</guid>
       <dc:creator> Asta Halkjær From, Frederik Krogsdal Jacobsen       </dc:creator>
       <pubDate>31 Jan 2022 00:00:00 +0000</pubDate>
       <description>
We formalize an automated theorem prover for first-order logic with
functions. The proof search procedure is based on sequent calculus and
we verify its soundness and completeness using the Abstract Soundness
and Abstract Completeness theories. Our analytic completeness proof
covers both open and closed formulas. Since our deterministic prover
considers only the subset of terms relevant to proving a given
sequent, we do so as well when building a countermodel from a failed
proof. We formally connect our prover with the proof system and
semantics of the existing SeCaV system. In particular, the
prover&#39;s output can be post-processed in Haskell to generate
human-readable SeCaV proofs which are also machine-verifiable proof
certificates.</description>
    </item>
    <item>
       <title>Interpolation Polynomials (in HOL-Algebra)</title>
              <link>https://www.isa-afp.org/entries/Interpolation_Polynomials_HOL_Algebra.html</link>
       <guid>https://www.isa-afp.org/entries/Interpolation_Polynomials_HOL_Algebra.html</guid>
       <dc:creator> Emin Karayel       </dc:creator>
       <pubDate>29 Jan 2022 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;A well known result from algebra is that, on any field, there
is exactly one polynomial of degree less than n interpolating n points
[&lt;a
href=&#34;https://doi.org/10.1017/CBO9780511814549&#34;&gt;1&lt;/a&gt;,
§7].&lt;/p&gt; &lt;p&gt;This entry contains a formalization of the
above result, as well as the following generalization in the case of
finite fields &lt;i&gt;F&lt;/i&gt;: There are
&lt;i&gt;|F|&lt;sup&gt;m-n&lt;/sup&gt;&lt;/i&gt; polynomials of degree
less than &lt;i&gt;m ≥ n&lt;/i&gt; interpolating the same n points,
where &lt;i&gt;|F|&lt;/i&gt; denotes the size of the domain of the
field. To establish the result the entry also includes a formalization
of Lagrange interpolation, which might be of independent
interest.&lt;/p&gt; &lt;p&gt;The formalized results are defined on the
algebraic structures from HOL-Algebra, which are distinct from the
type-class based structures defined in HOL. Note that there is an
existing formalization for polynomial interpolation and, in
particular, Lagrange interpolation by Thiemann and Yamada [&lt;a
href=&#34;https://www.isa-afp.org/entries/Polynomial_Interpolation.html&#34;&gt;2&lt;/a&gt;]
on the type-class based structures in HOL.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Median Method</title>
              <link>https://www.isa-afp.org/entries/Median_Method.html</link>
       <guid>https://www.isa-afp.org/entries/Median_Method.html</guid>
       <dc:creator> Emin Karayel       </dc:creator>
       <pubDate>25 Jan 2022 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The median method is an amplification result for randomized
approximation algorithms described in [&lt;a
href=&#34;https://doi.org/10.1006/jcss.1997.1545&#34;&gt;1&lt;/a&gt;].
Given an algorithm whose result is in a desired interval with a
probability larger than &lt;i&gt;1/2&lt;/i&gt;, it is possible to
improve the success probability, by running the algorithm multiple
times independently and using the median. In contrast to using the
mean, the amplification of the success probability grows exponentially
with the number of independent runs.&lt;/p&gt; &lt;p&gt;This entry
contains a formalization of the underlying theorem: Given a sequence
of n independent random variables, which are in a desired interval
with a probability &lt;i&gt;1/2 + a&lt;/i&gt;. Then their median will
be in the desired interval with a probability of &lt;i&gt;1 −
exp(−2a&lt;sup&gt;2&lt;/sup&gt; n)&lt;/i&gt;. In particular, the
success probability approaches &lt;i&gt;1&lt;/i&gt; exponentially with
the number of variables.&lt;/p&gt; &lt;p&gt;In addition to that, this
entry also contains a proof that order-statistics of Borel-measurable
random variables are themselves measurable and that generalized
intervals in linearly ordered Borel-spaces are measurable.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Actuarial Mathematics</title>
              <link>https://www.isa-afp.org/entries/Actuarial_Mathematics.html</link>
       <guid>https://www.isa-afp.org/entries/Actuarial_Mathematics.html</guid>
       <dc:creator> Yosuke Ito       </dc:creator>
       <pubDate>23 Jan 2022 00:00:00 +0000</pubDate>
       <description>
Actuarial Mathematics is a theory in applied mathematics, which is
mainly used for determining the prices of insurance products and
evaluating the liability of a company associating with insurance
contracts. It is related to calculus, probability theory and financial
theory, etc. In this entry, I formalize the very basic part of
Actuarial Mathematics in Isabelle/HOL. The first formalization is
about the theory of interest which deals with interest rates, present
value factors, an annuity certain, etc. I have already formalized the
basic part of Actuarial Mathematics in Coq
(https://github.com/Yosuke-Ito-345/Actuary). This entry is currently
the partial translation and a little generalization of the Coq
formalization. The further translation in Isabelle/HOL is now
proceeding.</description>
    </item>
    <item>
       <title>Irrational numbers from THE BOOK</title>
              <link>https://www.isa-afp.org/entries/Irrationals_From_THEBOOK.html</link>
       <guid>https://www.isa-afp.org/entries/Irrationals_From_THEBOOK.html</guid>
       <dc:creator> Lawrence C Paulson       </dc:creator>
       <pubDate>08 Jan 2022 00:00:00 +0000</pubDate>
       <description>
An elementary proof is formalised: that &lt;em&gt;exp r&lt;/em&gt; is irrational for
every nonzero rational number &lt;em&gt;r&lt;/em&gt;. The mathematical development comes
from the well-known volume &lt;em&gt;Proofs from THE BOOK&lt;/em&gt;,
by Aigner and Ziegler, who credit the idea to Hermite. The development
illustrates a number of basic Isabelle techniques: the manipulation of
summations, the calculation of quite complicated derivatives and the
estimation of integrals. We also see how to import another AFP entry (Stirling&#39;s formula).
As for the theorem itself, note that a much stronger and more general
result (the Hermite--Lindemann--Weierstraß transcendence theorem) is
already available in the AFP.</description>
    </item>
    <item>
       <title>Knight's Tour Revisited Revisited</title>
              <link>https://www.isa-afp.org/entries/Knights_Tour.html</link>
       <guid>https://www.isa-afp.org/entries/Knights_Tour.html</guid>
       <dc:creator> Lukas Koller       </dc:creator>
       <pubDate>04 Jan 2022 00:00:00 +0000</pubDate>
       <description>
This is a formalization of the article &lt;i&gt;Knight&#39;s Tour Revisited&lt;/i&gt; by
Cull and De Curtins where they prove the existence of a Knight&#39;s
path for arbitrary &lt;i&gt;n &amp;times; m&lt;/i&gt;-boards with &lt;i&gt;min(n,m) &amp;ge;
5&lt;/i&gt;. If &lt;i&gt;n &amp;middot; m&lt;/i&gt; is even, then there exists a Knight&#39;s
circuit.  A Knight&#39;s Path is a sequence of moves of a Knight on a
chessboard s.t. the Knight visits every square of a chessboard
exactly once.  Finding a Knight&#39;s path is a an instance of the
Hamiltonian path problem. A Knight&#39;s circuit is a Knight&#39;s path,
where additionally the Knight can move from the last square to the
first square of the path, forming a loop.  During the formalization
two mistakes in the original proof were discovered. These mistakes
are corrected in this formalization.</description>
    </item>
    <item>
       <title>Hyperdual Numbers and Forward Differentiation</title>
              <link>https://www.isa-afp.org/entries/Hyperdual.html</link>
       <guid>https://www.isa-afp.org/entries/Hyperdual.html</guid>
       <dc:creator> Filip Smola, Jacques Fleuriot       </dc:creator>
       <pubDate>31 Dec 2021 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;Hyperdual numbers are ones with a real component and a number
of infinitesimal components, usually written as $a_0 + a_1 \cdot
\epsilon_1 + a_2 \cdot \epsilon_2 + a_3 \cdot \epsilon_1\epsilon_2$.
They have been proposed by &lt;a
href=&#34;https://doi.org/10.2514/6.2011-886&#34;&gt;Fike and
Alonso&lt;/a&gt; in an approach to automatic
differentiation.&lt;/p&gt; &lt;p&gt;In this entry we formalise
hyperdual numbers and their application to forward differentiation. We
show them to be an instance of multiple algebraic structures and then,
along with facts about twice-differentiability, we define what we call
the hyperdual extensions of functions on real-normed fields. This
extension formally represents the proposed way that the first and
second derivatives of a function can be automatically calculated. We
demonstrate it on the standard logistic function $f(x) = \frac{1}{1 +
e^{-x}}$ and also reproduce the example analytic function $f(x) =
\frac{e^x}{\sqrt{sin(x)^3 + cos(x)^3}}$ used for demonstration by Fike
and Alonso.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Gale-Shapley Algorithm</title>
              <link>https://www.isa-afp.org/entries/Gale_Shapley.html</link>
       <guid>https://www.isa-afp.org/entries/Gale_Shapley.html</guid>
       <dc:creator> Tobias Nipkow       </dc:creator>
       <pubDate>29 Dec 2021 00:00:00 +0000</pubDate>
       <description>
This is a stepwise refinement and proof of the Gale-Shapley stable
matching (or marriage) algorithm down to executable code. Both a
purely functional implementation based on lists and a functional
implementation based on efficient arrays (provided by the Collections
Framework in the AFP) are developed. The latter implementation runs in
time &lt;i&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/i&gt; where
&lt;i&gt;n&lt;/i&gt; is the cardinality of the two sets to be matched.</description>
    </item>
    <item>
       <title>Roth's Theorem on Arithmetic Progressions</title>
              <link>https://www.isa-afp.org/entries/Roth_Arithmetic_Progressions.html</link>
       <guid>https://www.isa-afp.org/entries/Roth_Arithmetic_Progressions.html</guid>
       <dc:creator> Chelsea Edmonds, Angeliki Koutsoukou-Argyraki, Lawrence C. Paulson       </dc:creator>
       <pubDate>28 Dec 2021 00:00:00 +0000</pubDate>
       <description>
We formalise a proof of Roth&#39;s Theorem on Arithmetic
Progressions, a major result in additive combinatorics on the
existence of 3-term arithmetic progressions in subsets of natural
numbers. To this end, we follow a proof using graph regularity. We
employ our recent formalisation of Szemerédi&#39;s Regularity Lemma,
a major result in extremal graph theory, which we use here to prove
the Triangle Counting Lemma and the Triangle Removal Lemma. Our
sources are Yufei Zhao&#39;s MIT lecture notes
&#34;&lt;a href=&#34;https://ocw.mit.edu/courses/mathematics/18-217-graph-theory-and-additive-combinatorics-fall-2019/lecture-notes/MIT18_217F19_ch3.pdf&#34;&gt;Graph Theory and Additive Combinatorics&lt;/a&gt;&#34;
(revised version &lt;a href=&#34;https://yufeizhao.com/gtac/gtac17.pdf&#34;&gt;here&lt;/a&gt;)
and W.T. Gowers&#39;s Cambridge lecture notes
&#34;&lt;a href=&#34;https://www.dpmms.cam.ac.uk/~par31/notes/tic.pdf&#34;&gt;Topics in Combinatorics&lt;/a&gt;&#34;.
We also refer to the University of
Georgia notes by Stephanie Bell and Will Grodzicki,
&#34;&lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.432.327&#34;&gt;Using Szemerédi&#39;s Regularity Lemma to Prove Roth&#39;s Theorem&lt;/a&gt;&#34;.</description>
    </item>
    <item>
       <title>Markov Decision Processes with Rewards</title>
              <link>https://www.isa-afp.org/entries/MDP-Rewards.html</link>
       <guid>https://www.isa-afp.org/entries/MDP-Rewards.html</guid>
       <dc:creator> Maximilian Schäffeler, Mohammad Abdulaziz       </dc:creator>
       <pubDate>16 Dec 2021 00:00:00 +0000</pubDate>
       <description>
We present a formalization of Markov Decision Processes with rewards.
In particular we first build on Hölzl&#39;s formalization  of MDPs
(AFP entry: Markov_Models) and extend them with rewards. We proceed
with an analysis of the expected total discounted reward criterion for
infinite horizon MDPs. The central result is the construction of the
iteration rule for the Bellman operator. We prove the optimality
equations for this operator and show the existence of an optimal
stationary deterministic solution. The analysis can be used to obtain
dynamic programming algorithms such as value iteration and policy
iteration to solve MDPs with formal guarantees. Our formalization is
based on chapters 5 and 6 in Puterman&#39;s book &#34;Markov
Decision Processes: Discrete Stochastic Dynamic Programming&#34;.</description>
    </item>
    <item>
       <title>Verified Algorithms for Solving Markov Decision Processes</title>
              <link>https://www.isa-afp.org/entries/MDP-Algorithms.html</link>
       <guid>https://www.isa-afp.org/entries/MDP-Algorithms.html</guid>
       <dc:creator> Maximilian Schäffeler, Mohammad Abdulaziz       </dc:creator>
       <pubDate>16 Dec 2021 00:00:00 +0000</pubDate>
       <description>
We present a formalization of algorithms for solving Markov Decision
Processes (MDPs) with formal guarantees on the optimality of their
solutions. In particular we build on our analysis of the Bellman
operator for discounted infinite horizon MDPs. From the iterator rule
on the Bellman operator we directly derive executable value iteration
and policy iteration algorithms to iteratively solve finite MDPs. We
also prove correct optimized versions of value iteration that use
matrix splittings to improve the convergence rate. In particular, we
formally verify Gauss-Seidel value iteration and modified policy
iteration. The algorithms are evaluated on two standard examples from
the literature, namely, inventory management and gridworld. Our
formalization covers most of chapter 6 in Puterman&#39;s book
&#34;Markov Decision Processes: Discrete Stochastic Dynamic
Programming&#34;.</description>
    </item>
    <item>
       <title>Regular Tree Relations</title>
              <link>https://www.isa-afp.org/entries/Regular_Tree_Relations.html</link>
       <guid>https://www.isa-afp.org/entries/Regular_Tree_Relations.html</guid>
       <dc:creator> Alexander Lochmann, Bertram Felgenhauer, Christian Sternagel, René Thiemann, Thomas Sternagel       </dc:creator>
       <pubDate>15 Dec 2021 00:00:00 +0000</pubDate>
       <description>
Tree automata have good closure properties and therefore a commonly
used to prove/disprove properties. This formalization contains among
other things the proofs of many closure properties of tree automata
(anchored) ground tree transducers and regular relations. Additionally
it includes the well known pumping lemma and a lifting of the Myhill
Nerode theorem for regular languages to tree languages.  We want to
mention the existence of a &lt;a
href=&#34;https://www.isa-afp.org/entries/Tree-Automata.html&#34;&gt;tree
automata APF-entry&lt;/a&gt; developed by Peter Lammich. His work is
based on epsilon free top-down tree automata, while this entry builds
on bottom-up tree auotamta with epsilon transitions. Moreover our
formalization relies on the &lt;a
href=&#34;https://www.isa-afp.org/entries/Collections.html&#34;&gt;Collections
Framework&lt;/a&gt;, also by Peter Lammich, to obtain efficient code.
All proven constructions of the closure properties are exportable
using the Isabelle/HOL code generation facilities.</description>
    </item>
    <item>
       <title>Simplicial Complexes and Boolean functions</title>
              <link>https://www.isa-afp.org/entries/Simplicial_complexes_and_boolean_functions.html</link>
       <guid>https://www.isa-afp.org/entries/Simplicial_complexes_and_boolean_functions.html</guid>
       <dc:creator> Jesús Aransay, Alejandro del Campo, Julius Michaelis       </dc:creator>
       <pubDate>29 Nov 2021 00:00:00 +0000</pubDate>
       <description>
In this work we formalise the isomorphism between simplicial complexes
of dimension $n$ and monotone Boolean functions in $n$ variables,
mainly following the definitions and results as introduced by N. A.
Scoville. We also take advantage of the AFP
representation of &lt;a href=&#34;https://www.isa-afp.org/entries/ROBDD.html&#34;&gt;ROBDD&lt;/a&gt;
(Reduced Ordered Binary Decision Diagrams) to compute the ROBDD representation of a
given simplicial complex (by means of the isomorphism to Boolean
functions). Some examples of simplicial complexes and associated
Boolean functions are also presented.</description>
    </item>
  </channel>
</rss>
