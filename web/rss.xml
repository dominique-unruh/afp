<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>13 May 2020 00:00:00 +0000</pubDate>
    <item>
       <title>A Formalization of Knuth–Bendix Orders</title>
              <link>https://www.isa-afp.org/entries/Knuth_Bendix_Order.html</link>
       <guid>https://www.isa-afp.org/entries/Knuth_Bendix_Order.html</guid>
       <dc:creator> Christian Sternagel, René Thiemann       </dc:creator>
       <pubDate>13 May 2020 00:00:00 +0000</pubDate>
       <description>
We define a generalized version of Knuth&amp;ndash;Bendix orders,
including subterm coefficient functions. For these orders we formalize
several properties such as strong normalization, the subterm property,
closure properties under substitutions and contexts, as well as ground
totality.</description>
    </item>
    <item>
       <title>Irrationality Criteria for Series by Erdős and Straus</title>
              <link>https://www.isa-afp.org/entries/Irrational_Series_Erdos_Straus.html</link>
       <guid>https://www.isa-afp.org/entries/Irrational_Series_Erdos_Straus.html</guid>
       <dc:creator> Angeliki Koutsoukou-Argyraki, Wenda Li       </dc:creator>
       <pubDate>12 May 2020 00:00:00 +0000</pubDate>
       <description>
We formalise certain irrationality criteria for infinite series of the form:
\[\sum_{n=1}^\infty \frac{b_n}{\prod_{i=1}^n a_i} \]
where $\{b_n\}$ is a sequence of integers and $\{a_n\}$ a sequence of positive integers
with $a_n &gt;1$ for all large n. The results are due to P. Erdős and E. G. Straus
&lt;a href=&#34;https://projecteuclid.org/euclid.pjm/1102911140&#34;&gt;[1]&lt;/a&gt;.
In particular, we formalise Theorem 2.1, Corollary 2.10 and Theorem 3.1.
The latter is an application of Theorem 2.1 involving the prime numbers.</description>
    </item>
    <item>
       <title>Recursion Theorem in ZF</title>
              <link>https://www.isa-afp.org/entries/Recursion-Addition.html</link>
       <guid>https://www.isa-afp.org/entries/Recursion-Addition.html</guid>
       <dc:creator> Georgy Dunaev       </dc:creator>
       <pubDate>11 May 2020 00:00:00 +0000</pubDate>
       <description>
This document contains a proof of the recursion theorem. This is a
mechanization of the proof of the recursion theorem from the text &lt;i&gt;Introduction to
Set Theory&lt;/i&gt;, by Karel Hrbacek and Thomas Jech. This
implementation may be used as the basis for a model of Peano arithmetic in
ZF. While recursion and the natural numbers are already available in Isabelle/ZF, this clean development
is much easier to follow.</description>
    </item>
    <item>
       <title>An Efficient Normalisation Procedure for Linear Temporal Logic: Isabelle/HOL Formalisation</title>
              <link>https://www.isa-afp.org/entries/LTL_Normal_Form.html</link>
       <guid>https://www.isa-afp.org/entries/LTL_Normal_Form.html</guid>
       <dc:creator> Salomon Sickert       </dc:creator>
       <pubDate>08 May 2020 00:00:00 +0000</pubDate>
       <description>
In the mid 80s, Lichtenstein, Pnueli, and Zuck proved a classical
theorem stating that every formula of Past LTL (the extension of LTL
with past operators) is equivalent to a formula of the form
$\bigwedge_{i=1}^n \mathbf{G}\mathbf{F} \varphi_i \vee
\mathbf{F}\mathbf{G} \psi_i$,  where $\varphi_i$ and $\psi_i$ contain
only past operators. Some years later, Chang, Manna, and Pnueli built
on this result to derive a similar normal form for LTL. Both
normalisation procedures have a non-elementary worst-case blow-up, and
follow an involved path from formulas to counter-free automata to
star-free regular expressions and back to formulas. We improve on both
points. We present an executable formalisation of a direct and purely
syntactic normalisation procedure for LTL yielding a normal form,
comparable to the one by Chang, Manna, and Pnueli, that has only a
single exponential blow-up.</description>
    </item>
    <item>
       <title>Formalization of Forcing in Isabelle/ZF</title>
              <link>https://www.isa-afp.org/entries/Forcing.html</link>
       <guid>https://www.isa-afp.org/entries/Forcing.html</guid>
       <dc:creator> Emmanuel Gunther, Miguel Pagano, Pedro Sánchez Terraf       </dc:creator>
       <pubDate>06 May 2020 00:00:00 +0000</pubDate>
       <description>
We formalize the theory of forcing in the set theory framework of
Isabelle/ZF. Under the assumption of the existence of a countable
transitive model of ZFC, we construct a proper generic extension and
show that the latter also satisfies ZFC.</description>
    </item>
    <item>
       <title>Banach-Steinhaus Theorem</title>
              <link>https://www.isa-afp.org/entries/Banach_Steinhaus.html</link>
       <guid>https://www.isa-afp.org/entries/Banach_Steinhaus.html</guid>
       <dc:creator> Dominique Unruh, Jose Manuel Rodriguez Caballero       </dc:creator>
       <pubDate>02 May 2020 00:00:00 +0000</pubDate>
       <description>
We formalize in Isabelle/HOL a result
due to S. Banach and H. Steinhaus known as
the Banach-Steinhaus theorem or Uniform boundedness principle: a
pointwise-bounded family of continuous linear operators from a Banach
space to a normed space is uniformly bounded. Our approach is an
adaptation to Isabelle/HOL of a proof due to A. Sokal.</description>
    </item>
    <item>
       <title>Attack Trees in Isabelle for GDPR compliance of IoT healthcare systems</title>
              <link>https://www.isa-afp.org/entries/Attack_Trees.html</link>
       <guid>https://www.isa-afp.org/entries/Attack_Trees.html</guid>
       <dc:creator> Florian Kammueller       </dc:creator>
       <pubDate>27 Apr 2020 00:00:00 +0000</pubDate>
       <description>
In this article, we present a proof theory for Attack Trees. Attack
Trees are a well established and useful model for the construction of
attacks on systems since they allow a stepwise exploration of high
level attacks in application scenarios. Using the expressiveness of
Higher Order Logic in Isabelle, we develop a generic
theory of Attack Trees with a state-based semantics based on Kripke
structures and CTL. The resulting framework
allows mechanically supported logic analysis of the meta-theory of the
proof calculus of Attack Trees and at the same time the developed
proof theory enables application to case studies. A central
correctness and completeness result proved in Isabelle establishes a
connection between the notion of Attack Tree validity and CTL. The
application is illustrated on the example of a healthcare IoT system
and GDPR compliance verification.</description>
    </item>
    <item>
       <title>Power Sum Polynomials</title>
              <link>https://www.isa-afp.org/entries/Power_Sum_Polynomials.html</link>
       <guid>https://www.isa-afp.org/entries/Power_Sum_Polynomials.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>24 Apr 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides a formalisation of the symmetric
multivariate polynomials known as &lt;em&gt;power sum
polynomials&lt;/em&gt;. These are of the form
p&lt;sub&gt;n&lt;/sub&gt;(&lt;em&gt;X&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,
&lt;em&gt;X&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;) =
&lt;em&gt;X&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;n&lt;/sup&gt;
+ &amp;hellip; +
X&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;n&lt;/sup&gt;.
A formal proof of the Girard–Newton Theorem is also given. This
theorem relates the power sum polynomials to the elementary symmetric
polynomials s&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; in the form
of a recurrence relation
(-1)&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;
&lt;em&gt;k&lt;/em&gt; s&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;
=
&amp;sum;&lt;sub&gt;i&amp;isinv;[0,&lt;em&gt;k&lt;/em&gt;)&lt;/sub&gt;
(-1)&lt;sup&gt;i&lt;/sup&gt; s&lt;sub&gt;i&lt;/sub&gt;
p&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&amp;thinsp;.&lt;/p&gt;
&lt;p&gt;As an application, this is then used to solve a generalised
form of a puzzle given as an exercise in Dummit and Foote&#39;s
&lt;em&gt;Abstract Algebra&lt;/em&gt;: For &lt;em&gt;k&lt;/em&gt;
complex unknowns &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;,
&amp;hellip;,
&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;,
define p&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt; :=
&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sup&gt;
+ &amp;hellip; +
&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sup&gt;.
Then for each vector &lt;em&gt;a&lt;/em&gt; &amp;isinv;
&amp;#x2102;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;, show that
there is exactly one solution to the system p&lt;sub&gt;1&lt;/sub&gt;
= a&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;,
p&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; =
a&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; up to permutation of
the
&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;
and determine the value of
p&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; for
i&amp;gt;k.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Lambert W Function on the Reals</title>
              <link>https://www.isa-afp.org/entries/Lambert_W.html</link>
       <guid>https://www.isa-afp.org/entries/Lambert_W.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>24 Apr 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The Lambert &lt;em&gt;W&lt;/em&gt; function is a multi-valued
function defined as the inverse function of &lt;em&gt;x&lt;/em&gt;
&amp;#x21A6; &lt;em&gt;x&lt;/em&gt;
e&lt;sup&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sup&gt;. Besides numerous
applications in combinatorics, physics, and engineering, it also
frequently occurs when solving equations containing both
e&lt;sup&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sup&gt; and
&lt;em&gt;x&lt;/em&gt;, or both &lt;em&gt;x&lt;/em&gt; and log
&lt;em&gt;x&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;This article provides a
definition of the two real-valued branches
&lt;em&gt;W&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;)
and
&lt;em&gt;W&lt;/em&gt;&lt;sub&gt;-1&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;)
and proves various properties such as basic identities and
inequalities, monotonicity, differentiability, asymptotic expansions,
and the MacLaurin series of
&lt;em&gt;W&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;)
at &lt;em&gt;x&lt;/em&gt; = 0.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Gaussian Integers</title>
              <link>https://www.isa-afp.org/entries/Gaussian_Integers.html</link>
       <guid>https://www.isa-afp.org/entries/Gaussian_Integers.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>24 Apr 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The Gaussian integers are the subring &amp;#8484;[i] of the
complex numbers, i. e. the ring of all complex numbers with integral
real and imaginary part. This article provides a definition of this
ring as well as proofs of various basic properties, such as that they
form a Euclidean ring and a full classification of their primes. An
executable (albeit not very efficient) factorisation algorithm is also
provided.&lt;/p&gt; &lt;p&gt;Lastly, this Gaussian integer
formalisation is used in two short applications:&lt;/p&gt; &lt;ol&gt;
&lt;li&gt; The characterisation of all positive integers that can be
written as sums of two squares&lt;/li&gt; &lt;li&gt; Euclid&#39;s
formula for primitive Pythagorean triples&lt;/li&gt; &lt;/ol&gt;
&lt;p&gt;While elementary proofs for both of these are already
available in the AFP, the theory of Gaussian integers provides more
concise proofs and a more high-level view.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Matrices for ODEs</title>
              <link>https://www.isa-afp.org/entries/Matrices_for_ODEs.html</link>
       <guid>https://www.isa-afp.org/entries/Matrices_for_ODEs.html</guid>
       <dc:creator> Jonathan Julian Huerta y Munive       </dc:creator>
       <pubDate>19 Apr 2020 00:00:00 +0000</pubDate>
       <description>
Our theories formalise various matrix properties that serve to
establish existence, uniqueness and characterisation of the solution
to affine systems of ordinary differential equations (ODEs). In
particular, we formalise the operator and maximum norm of matrices.
Then we use them to prove that square matrices form a Banach space,
and in this setting, we show an instance of Picard-Lindelöf’s
theorem for affine systems of ODEs. Finally, we use this formalisation
to verify three simple hybrid programs.</description>
    </item>
    <item>
       <title>Authenticated Data Structures As Functors</title>
              <link>https://www.isa-afp.org/entries/ADS_Functor.html</link>
       <guid>https://www.isa-afp.org/entries/ADS_Functor.html</guid>
       <dc:creator> Andreas Lochbihler, Ognjen Marić       </dc:creator>
       <pubDate>16 Apr 2020 00:00:00 +0000</pubDate>
       <description>
Authenticated data structures allow several systems to convince each
other that they are referring to the same data structure, even if each
of them knows only a part of the data structure. Using inclusion
proofs, knowledgeable systems can selectively share their knowledge
with other systems and the latter can verify the authenticity of what
is being shared.  In this article, we show how to modularly define
authenticated data structures, their inclusion proofs, and operations
thereon as datatypes in Isabelle/HOL, using a shallow embedding.
Modularity allows us to construct complicated trees from reusable
building blocks, which we call Merkle functors. Merkle functors
include sums, products, and function spaces and are closed under
composition and least fixpoints.  As a practical application, we model
the hierarchical transactions of &lt;a
href=&#34;https://www.canton.io&#34;&gt;Canton&lt;/a&gt;, a
practical interoperability protocol for distributed ledgers, as
authenticated data structures. This is a first step towards
formalizing the Canton protocol and verifying its integrity and
security guarantees.</description>
    </item>
    <item>
       <title>Formalization of an Algorithm for Greedily Computing Associative Aggregations on Sliding Windows</title>
              <link>https://www.isa-afp.org/entries/Sliding_Window_Algorithm.html</link>
       <guid>https://www.isa-afp.org/entries/Sliding_Window_Algorithm.html</guid>
       <dc:creator> Lukas Heimes, Dmitriy Traytel, Joshua Schneider       </dc:creator>
       <pubDate>10 Apr 2020 00:00:00 +0000</pubDate>
       <description>
Basin et al.&#39;s &lt;a
href=&#34;https://doi.org/10.1016/j.ipl.2014.09.009&#34;&gt;sliding
window algorithm (SWA)&lt;/a&gt; is an algorithm for combining the
elements of subsequences of a sequence with an associative operator.
It is greedy and minimizes the number of operator applications. We
formalize the algorithm and verify its functional correctness. We
extend the algorithm with additional operations and provide an
alternative interface to the slide operation that does not require the
entire input sequence.</description>
    </item>
    <item>
       <title>A Comprehensive Framework for Saturation Theorem Proving</title>
              <link>https://www.isa-afp.org/entries/Saturation_Framework.html</link>
       <guid>https://www.isa-afp.org/entries/Saturation_Framework.html</guid>
       <dc:creator> Sophie Tourret       </dc:creator>
       <pubDate>09 Apr 2020 00:00:00 +0000</pubDate>
       <description>
This Isabelle/HOL formalization is the companion of the technical
report “A comprehensive framework for saturation theorem proving”,
itself companion of the eponym IJCAR 2020 paper, written by Uwe
Waldmann, Sophie Tourret, Simon Robillard and Jasmin Blanchette. It
verifies a framework for formal refutational completeness proofs of
abstract provers that implement saturation calculi, such as ordered
resolution or superposition, and allows to model entire prover
architectures in such a way that the static refutational completeness
of a calculus immediately implies the dynamic  refutational
completeness of a prover implementing the calculus using a variant of
the given clause loop.  The technical report “A comprehensive
framework for saturation theorem proving” is available &lt;a
href=&#34;http://matryoshka.gforge.inria.fr/pubs/satur_report.pdf&#34;&gt;on
the Matryoshka website&lt;/a&gt;. The names of the Isabelle lemmas and
theorems corresponding to the results in the report are indicated in
the margin of the report.</description>
    </item>
    <item>
       <title>Formalization of an Optimized Monitoring Algorithm for Metric First-Order Dynamic Logic with Aggregations</title>
              <link>https://www.isa-afp.org/entries/MFODL_Monitor_Optimized.html</link>
       <guid>https://www.isa-afp.org/entries/MFODL_Monitor_Optimized.html</guid>
       <dc:creator> Thibault Dardinier, Lukas Heimes, Martin Raszyk, Joshua Schneider, Dmitriy Traytel       </dc:creator>
       <pubDate>09 Apr 2020 00:00:00 +0000</pubDate>
       <description>
A monitor is a runtime verification tool that solves the following
problem: Given a stream of time-stamped events and a policy formulated
in a specification language, decide whether the policy is satisfied at
every point in the stream. We verify the correctness of an executable
monitor for specifications given as formulas in metric first-order
dynamic logic (MFODL), which combines the features of metric
first-order temporal logic (MFOTL) and metric dynamic logic. Thus,
MFODL supports real-time constraints, first-order parameters, and
regular expressions. Additionally, the monitor supports aggregation
operations such as count and sum. This formalization, which is
described in a &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/ijcar20-verimonplus/verimonplus.pdf&#34;&gt;
forthcoming paper at IJCAR 2020&lt;/a&gt;, significantly extends &lt;a
href=&#34;https://www.isa-afp.org/entries/MFOTL_Monitor.html&#34;&gt;previous
work on a verified monitor&lt;/a&gt; for MFOTL. Apart from the
addition of regular expressions and aggregations, we implemented &lt;a
href=&#34;https://www.isa-afp.org/entries/Generic_Join.html&#34;&gt;multi-way
joins&lt;/a&gt; and a specialized sliding window algorithm to further
optimize the monitor.</description>
    </item>
    <item>
       <title>Lucas's Theorem</title>
              <link>https://www.isa-afp.org/entries/Lucas_Theorem.html</link>
       <guid>https://www.isa-afp.org/entries/Lucas_Theorem.html</guid>
       <dc:creator> Chelsea Edmonds       </dc:creator>
       <pubDate>07 Apr 2020 00:00:00 +0000</pubDate>
       <description>
This work presents a formalisation of a generating function proof for
Lucas&#39;s theorem. We first outline extensions to the existing
Formal Power Series (FPS) library, including an equivalence relation
for coefficients modulo &lt;em&gt;n&lt;/em&gt;, an alternate binomial theorem statement,
and a formalised proof of the Freshman&#39;s dream (mod &lt;em&gt;p&lt;/em&gt;) lemma.
The second part of the work presents the formal proof of Lucas&#39;s
Theorem. Working backwards, the formalisation first proves a well
known corollary of the theorem which is easier to formalise, and then
applies induction to prove the original theorem statement. The proof
of the corollary aims to provide a good example of a formalised
generating function equivalence proof using the FPS library. The final
theorem statement is intended to be integrated into the formalised
proof of Hilbert&#39;s 10th Problem.</description>
    </item>
    <item>
       <title>Strong Eventual Consistency of the Collaborative Editing Framework WOOT</title>
              <link>https://www.isa-afp.org/entries/WOOT_Strong_Eventual_Consistency.html</link>
       <guid>https://www.isa-afp.org/entries/WOOT_Strong_Eventual_Consistency.html</guid>
       <dc:creator> Emin Karayel, Edgar Gonzàlez       </dc:creator>
       <pubDate>25 Mar 2020 00:00:00 +0000</pubDate>
       <description>
Commutative Replicated Data Types (CRDTs) are a promising new class of
data structures for large-scale shared mutable content in applications
that only require eventual consistency. The WithOut Operational
Transforms (WOOT) framework is a CRDT for collaborative text editing
introduced by Oster et al. (CSCW 2006) for which the eventual
consistency property was verified only for a bounded model to date. We
contribute a formal proof for WOOTs strong eventual consistency.</description>
    </item>
    <item>
       <title>Furstenberg's topology and his proof of the infinitude of primes</title>
              <link>https://www.isa-afp.org/entries/Furstenberg_Topology.html</link>
       <guid>https://www.isa-afp.org/entries/Furstenberg_Topology.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>22 Mar 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article gives a formal version of Furstenberg&#39;s
topological proof of the infinitude of primes. He defines a topology
on the integers based on arithmetic progressions (or, equivalently,
residue classes). Using some fairly obvious properties of this
topology, the infinitude of primes is then easily obtained.&lt;/p&gt;
&lt;p&gt;Apart from this, this topology is also fairly ‘nice’ in
general: it is second countable, metrizable, and perfect. All of these
(well-known) facts are formally proven, including an explicit metric
for the topology given by Zulfeqarr.&lt;/p&gt;</description>
    </item>
    <item>
       <title>An Under-Approximate Relational Logic</title>
              <link>https://www.isa-afp.org/entries/Relational-Incorrectness-Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Relational-Incorrectness-Logic.html</guid>
       <dc:creator> Toby Murray       </dc:creator>
       <pubDate>12 Mar 2020 00:00:00 +0000</pubDate>
       <description>
Recently, authors have proposed under-approximate logics for reasoning
about programs. So far, all such logics have been confined to
reasoning about individual program behaviours. Yet there exist many
over-approximate relational logics for reasoning about pairs of
programs and relating their behaviours. We present the first
under-approximate relational logic, for the simple imperative language
IMP. We prove our logic is both sound and complete. Additionally, we
show how reasoning in this logic can be decomposed into non-relational
reasoning in an under-approximate Hoare logic, mirroring Beringer’s
result for over-approximate relational logics. We illustrate the
application of our logic on some small examples in which we provably
demonstrate the presence of insecurity.</description>
    </item>
    <item>
       <title>Hello World</title>
              <link>https://www.isa-afp.org/entries/Hello_World.html</link>
       <guid>https://www.isa-afp.org/entries/Hello_World.html</guid>
       <dc:creator> Cornelius Diekmann, Lars Hupel       </dc:creator>
       <pubDate>07 Mar 2020 00:00:00 +0000</pubDate>
       <description>
In this article, we present a formalization of the well-known
&#34;Hello, World!&#34; code, including a formal framework for
reasoning about IO. Our model is inspired by the handling of IO in
Haskell. We start by formalizing the 🌍 and embrace the IO monad
afterwards. Then we present a sample main :: IO (), followed by its
proof of correctness.</description>
    </item>
    <item>
       <title>Implementing the Goodstein Function in &lambda;-Calculus</title>
              <link>https://www.isa-afp.org/entries/Goodstein_Lambda.html</link>
       <guid>https://www.isa-afp.org/entries/Goodstein_Lambda.html</guid>
       <dc:creator> Bertram Felgenhauer       </dc:creator>
       <pubDate>21 Feb 2020 00:00:00 +0000</pubDate>
       <description>
In this formalization, we develop an implementation of the Goodstein
function G in plain &amp;lambda;-calculus, linked to a concise, self-contained
specification. The implementation works on a Church-encoded
representation of countable ordinals. The initial conversion to
hereditary base 2 is not covered, but the material is sufficient to
compute the particular value G(16), and easily extends to other fixed
arguments.</description>
    </item>
    <item>
       <title>A Generic Framework for Verified Compilers</title>
              <link>https://www.isa-afp.org/entries/VeriComp.html</link>
       <guid>https://www.isa-afp.org/entries/VeriComp.html</guid>
       <dc:creator> Martin Desharnais       </dc:creator>
       <pubDate>10 Feb 2020 00:00:00 +0000</pubDate>
       <description>
This is a generic framework for formalizing compiler transformations.
It leverages Isabelle/HOL’s locales to abstract over concrete
languages and transformations. It states common definitions for
language semantics, program behaviours, forward and backward
simulations, and compilers. We provide generic operations, such as
simulation and compiler composition, and prove general (partial)
correctness theorems, resulting in reusable proof components.</description>
    </item>
    <item>
       <title>Arithmetic progressions and relative primes</title>
              <link>https://www.isa-afp.org/entries/Arith_Prog_Rel_Primes.html</link>
       <guid>https://www.isa-afp.org/entries/Arith_Prog_Rel_Primes.html</guid>
       <dc:creator> José Manuel Rodríguez Caballero       </dc:creator>
       <pubDate>01 Feb 2020 00:00:00 +0000</pubDate>
       <description>
This article provides a formalization of the solution obtained by the
author of the Problem “ARITHMETIC PROGRESSIONS” from the
&lt;a href=&#34;https://www.ocf.berkeley.edu/~wwu/riddles/putnam.shtml&#34;&gt;
Putnam exam problems of 2002&lt;/a&gt;. The statement of the problem is
as follows: For which integers &lt;em&gt;n&lt;/em&gt; &gt; 1 does the set of positive
integers less than and relatively prime to &lt;em&gt;n&lt;/em&gt; constitute an
arithmetic progression?</description>
    </item>
    <item>
       <title>A Hierarchy of Algebras for Boolean Subsets</title>
              <link>https://www.isa-afp.org/entries/Subset_Boolean_Algebras.html</link>
       <guid>https://www.isa-afp.org/entries/Subset_Boolean_Algebras.html</guid>
       <dc:creator> Walter Guttmann, Bernhard Möller       </dc:creator>
       <pubDate>31 Jan 2020 00:00:00 +0000</pubDate>
       <description>
We present a collection of axiom systems for the construction of
Boolean subalgebras of larger overall algebras. The subalgebras are
defined as the range of a complement-like operation on a semilattice.
This technique has been used, for example, with the antidomain
operation, dynamic negation and Stone algebras. We present a common
ground for these constructions based on a new equational
axiomatisation of Boolean algebras.</description>
    </item>
    <item>
       <title>Mersenne primes and the Lucas–Lehmer test</title>
              <link>https://www.isa-afp.org/entries/Mersenne_Primes.html</link>
       <guid>https://www.isa-afp.org/entries/Mersenne_Primes.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>17 Jan 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides formal proofs of basic properties of
Mersenne numbers, i. e. numbers of the form
2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; - 1, and especially of
Mersenne primes.&lt;/p&gt; &lt;p&gt;In particular, an efficient,
verified, and executable version of the Lucas&amp;ndash;Lehmer test is
developed. This test decides primality for Mersenne numbers in time
polynomial in &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Verified Approximation Algorithms</title>
              <link>https://www.isa-afp.org/entries/Approximation_Algorithms.html</link>
       <guid>https://www.isa-afp.org/entries/Approximation_Algorithms.html</guid>
       <dc:creator> Robin Eßmann, Tobias Nipkow, Simon Robillard       </dc:creator>
       <pubDate>16 Jan 2020 00:00:00 +0000</pubDate>
       <description>
We present the first formal verification of approximation algorithms
for NP-complete optimization problems: vertex cover, independent set,
load balancing, and bin packing. The proofs correct incompletenesses
in existing proofs and improve the approximation ratio in one case.</description>
    </item>
    <item>
       <title>Closest Pair of Points Algorithms</title>
              <link>https://www.isa-afp.org/entries/Closest_Pair_Points.html</link>
       <guid>https://www.isa-afp.org/entries/Closest_Pair_Points.html</guid>
       <dc:creator> Martin Rau, Tobias Nipkow       </dc:creator>
       <pubDate>13 Jan 2020 00:00:00 +0000</pubDate>
       <description>
This entry provides two related verified divide-and-conquer algorithms
solving the fundamental &lt;em&gt;Closest Pair of Points&lt;/em&gt;
problem in Computational Geometry. Functional correctness and the
optimal running time of &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;) are
proved. Executable code is generated which is empirically competitive
with handwritten reference implementations.</description>
    </item>
    <item>
       <title>Skip Lists</title>
              <link>https://www.isa-afp.org/entries/Skip_Lists.html</link>
       <guid>https://www.isa-afp.org/entries/Skip_Lists.html</guid>
       <dc:creator> Max W. Haslbeck, Manuel Eberl       </dc:creator>
       <pubDate>09 Jan 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt; Skip lists are sorted linked lists enhanced with shortcuts
and are an alternative to binary search trees. A skip lists consists
of multiple levels of sorted linked lists where a list on level n is a
subsequence of the list on level n − 1. In the ideal case, elements
are skipped in such a way that a lookup in a skip lists takes O(log n)
time. In a randomised skip list the skipped elements are choosen
randomly. &lt;/p&gt; &lt;p&gt; This entry contains formalized proofs
of the textbook results about the expected height and the expected
length of a search path in a randomised skip list. &lt;/p&gt;</description>
    </item>
    <item>
       <title>Bicategories</title>
              <link>https://www.isa-afp.org/entries/Bicategory.html</link>
       <guid>https://www.isa-afp.org/entries/Bicategory.html</guid>
       <dc:creator> Eugene W. Stark       </dc:creator>
       <pubDate>06 Jan 2020 00:00:00 +0000</pubDate>
       <description>
Taking as a starting point the author&#39;s previous work on
developing aspects of category theory in Isabelle/HOL, this article
gives a compatible formalization of the notion of
&#34;bicategory&#34; and develops a framework within which formal
proofs of facts about bicategories can be given.  The framework
includes a number of basic results, including the Coherence Theorem,
the Strictness Theorem, pseudofunctors and biequivalence, and facts
about internal equivalences and adjunctions in a bicategory.  As a
driving application and demonstration of the utility of the framework,
it is used to give a formal proof of a theorem, due to Carboni,
Kasangian, and Street, that characterizes up to biequivalence the
bicategories of spans in a category with pullbacks.  The formalization
effort necessitated the filling-in of many details that were not
evident from the brief presentation in the original paper, as well as
identifying a few minor corrections along the way.</description>
    </item>
    <item>
       <title>The Irrationality of ζ(3)</title>
              <link>https://www.isa-afp.org/entries/Zeta_3_Irrational.html</link>
       <guid>https://www.isa-afp.org/entries/Zeta_3_Irrational.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>27 Dec 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides a formalisation of Beukers&#39;s
straightforward analytic proof that ζ(3) is irrational. This was first
proven by Apéry (which is why this result is also often called
‘Apéry&#39;s Theorem’) using a more algebraic approach. This
formalisation follows &lt;a
href=&#34;http://people.math.sc.edu/filaseta/gradcourses/Math785/Math785Notes4.pdf&#34;&gt;Filaseta&#39;s
presentation&lt;/a&gt; of Beukers&#39;s proof.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
